[{"content":"C++技术Q\u0026amp;A（二）\r多线程里面的promise和future，以及和atomic的差别，锁\nstd::move\n用于实现移动语义。将对象的所有权从一个对象转移到另一个对象，从而避免不必要的复制，提高程序性能。\nstd::move的主要作用是将一个左值强制转换为右值引用，从而使得该对象能够参与移动语义。例如，当你不再需要使用某个对象时，可以用std::move将它转换为右值引用，以便资源被高效地“移动”到新对象中，而不是“复制”。\n使用std::move后，原对象不再有效。\n左值和右值拷贝\n左值（lvalue）和右值（rvalue）是表达式的两种基本类型。\n左值是一个表达式，表示内存中的一个对象，可以获取该对象的地址。左值通常是变量、对象的成员、或者返回左值引用的函数调用。\n右值：通常是表达式的结果、常量、或者临时对象。它表示临时值或字面量。生命周期短，只能出现在赋值操作的右边。\n右值引用“\u0026amp;\u0026amp;”：允许我们操作即将被销毁的对象，从而实现移动语义。\n左值拷贝：当你将一个对象赋值给另一个对象时，如果被赋值的对象是左值（持久存在），通常会发生拷贝操作。这意味着所有权不会转移，源对象和目标对象都有独立的内存。\n1 2 std::string s1 = \u0026#34;Hello\u0026#34;; std::string s2 = s1; // s1 是左值，发生深拷贝 右值引用：当你通过右值引用将临时对象赋值给另一个对象时，移动语义可能会被触发，资源将被移动而不是拷贝。这提高了性能，因为避免了不必要的内存分配和复制。\n1 std::string s3 = std::move(s1); // s1 是左值，通过 std::move 转换为右值，触发移动语义 构造函数和析构函数里面能不能是虚函数\n构造函数不能是虚函数。在基类构造函数执行时，派生类的虚函数表还未初始化完毕。因此，无法在构造函数中正确调用派生类的虚函数版本。 this指针能不能删除\nthis指针：在一个对象上调用成员函数时，该函数会自动接收一个指向该对象的指针，这个指针就是this指针。this指针指向调用该成员函数的对象的内存地址，使得函数能够访问该对象的成员变量和其他成员函数。确保了函数可以正确地访问和操作属于当前对象的成员变量。 this指针不能被直接删除或修改，它是由编译器管理的指向当前对象的指针。 虽然可以通过delete this来销毁对象，但这种操作非常危险。 拷贝构造，unique_ptr为什么不能拷贝构造\n拷贝构造函数允许你创建一个新的对象，并将现有对象的内容复制到新对象中。 std::unique_ptr 不允许多个指针同时拥有相同的资源，从而避免了潜在的双重释放和悬空指针问题。 虽然 std::unique_ptr 不支持拷贝构造，但它支持移动构造和移动赋值，能通过 std::move 转移所有权。 std::unique_ptr ptr2 = std::move(ptr1); 什么情况下拷贝构造函数设成private\n独立资源的管理 单例模式 禁止复制的对象 struct和class的区别\nstruct 中的成员（包括数据成员和成员函数）是 公有（public） 的。class相反，默认都是私有。 他们的继承默认方式同上。 struct 更倾向于用来定义数据结构。class 更倾向于用来定义对象和行为 在迭代器的循环中，为什么不能调用erase函数\n当你从容器中删除一个元素时，指向该元素的迭代器会失效。对于一些容器，删除某个元素后，该元素之后的所有迭代器也可能会失效。\n解决方案：使用 erase 返回的迭代器来更新循环中的迭代器，确保迭代器始终有效。\n1 2 3 4 5 6 7 8 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; for (auto it = vec.begin(); it != vec.end(); ) { if (*it == 3) { it = vec.erase(it); // 使用erase返回的有效迭代器 } else { ++it; // 仅在没有删除元素时递增迭代器 } } 讲讲虚函数、虚表、虚指针\n当一个类中包含虚函数时，编译器会在对象中插入一个指向虚表的指针（即虚表指针 vptr），而虚表则保存了这个类的所有虚函数的地址。 虚表中的每个元素对应类的一个虚函数，存储的是该函数的地址。 如果类继承了基类并重写了基类的虚函数，派生类的虚表中对应项会指向派生类的重写版本。当类派生出子类时，如果子类重写了基类的虚函数，子类的虚表中的相应指针会被更新为指向子类的函数。 虚函数调用过程： 通过对象的 vptr 找到对应的虚表。 根据虚函数在类中声明的顺序，从虚表中找到对应的函数指针。 调用虚表中对应的函数指针，执行派生类中的虚函数实现。 虚表指针是在对象构造时初始化的。 基类的析构函数为什么要定义成虚函数\n如果基类的析构函数不是虚函数，当我们通过基类指针删除派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类中的资源（如动态分配的内存、文件句柄等）无法被正确释放，造成资源泄漏。 四种类型转换运算符\n分别是static_cast、dynamic_cast、const_cast和reinterpret_cast static_cast 是一种用于执行常规类型转换的运算符。 dynamic_cast 主要用于在多态情况下进行类型转换。多态类型的指针或引用的转换：用于从基类向派生类的安全转换，确保转换是有效的。如果转换无效，指针类型会返回 nullptr。dynamic_cast 只能用于包含虚函数的类，即具有多态性。如果类中没有虚函数，dynamic_cast 将无法使用。 const_cast 用于在类型转换中添加或移除 const 或 volatile 修饰符。它是唯一可以修改常量性的类型转换运算符。 reinterpret_cast 用于进行几乎任意的类型转换。这种转换是非常底层的，它不会考虑类型的实际含义。很危险。 c++内存\n他们通常被分成几个区域。\n静态/全局内存区（Static/Global Memory Area） 存放内容：存储全局变量、静态变量（static）、常量（const）以及一些特殊变量。 生命周期：这些变量在程序启动时分配，并在程序结束时销毁，生命周期贯穿整个程序运行期。 栈区（Stack Area） 存放内容：存储局部变量和函数调用时的参数以及返回地址。每次函数调用都会在栈中创建一个新的栈帧，用于保存该函数的局部变量、参数和返回地址。 生命周期：局部变量的生命周期与其所在的函数调用相关，当函数结束时，这些变量被自动销毁。 堆区（Heap Area） 存放内容：通过动态内存分配（如 new、malloc）分配的内存块。 生命周期：由程序员显式管理，必须显式释放（如 delete、free），否则可能导致内存泄漏。 智能指针有哪些，分别如何使用\nstd::shared_ptr是一个共享所有权的智能指针，多个std::shared_ptr可以指向同一对象，并且通过引用计数管理资源。当最后一个std::shared_ptr离开作用域时，资源才会被释放。\n​\t使用场景：当需要多个所有者共同管理一个对象的生命周期时。 适用于需要共享对象但无法明确确定对象生命周期的场景，例如观察者模式。\nstd::unique_ptr在第20条说过。\nstd::weak_ptr：用于观察std::shared_ptr所管理的资源，避免循环引用，不影响引用计数。\n使用智能指针可以显著减少内存管理错误，提高代码的安全性和可维护性。\nSTL\n容器（Containers） 迭代器 算法 非变更算法（Non-modifying Algorithms）：不改变容器内容，只读操作。 std::for_each：对范围内的每个元素应用操作。 std::find：在范围内查找指定元素。 std::count：计算指定元素的出现次数。 变更算法（Modifying Algorithms）：会修改容器内容。 std::copy：将元素复制到另一个范围。 std::transform：对每个元素应用操作并存储结果。 std::fill：用指定值填充范围。 排序算法（Sorting Algorithms）：用于排序和排列元素。 std::sort：对范围内的元素进行升序排序。 std::reverse：反转范围内的元素顺序。 std::shuffle：随机打乱范围内的元素顺序。 数值算法（Numeric Algorithms）：用于数值计算。 std::accumulate：计算范围内元素的累积和。 std::inner_product：计算内积。 std::partial_sum：计算部分和。 函数对象（Function Objects, Functors） 适配器（Adapters） 。。。。。。 变量的声明和定义\n声明（Declaration）告诉编译器变量的名称和类型，但不会为变量分配内存或初始化值。声明通常用于在多个文件之间共享变量的情况。例如，如果你在一个头文件中声明一个变量，那么这个变量就可以在其他源文件中使用。 定义（Definition）不仅告诉编译器变量的名称和类型，还为变量分配内存，并且可以初始化它。定义通常只出现一次，因为它负责实际创建变量。 extern关键字通常用于变量的声明，以表示变量定义在其他文件中。例如，在头文件中声明全局变量，在源文件中定义。 extern 和 extern C有什么区别\nextern \u0026ldquo;C\u0026rdquo; 是一种 C++ 语言的扩展，用于指示编译器使用 C 语言的函数命名和调用约定。\n1 2 3 4 5 6 7 8 9 10 11 // C++ 头文件中 extern \u0026#34;C\u0026#34; { void myFunction(int); // 这会使用 C 的命名约定 } // C++ 源文件中 extern \u0026#34;C\u0026#34; { void myFunction(int x) { // 函数实现 } } 静态成员函数\n静态成员函数（Static Member Function）是属于类本身的函数，而不是某个具体对象的成员函数。 特点： 不依赖于对象：静态成员函数不需要通过对象来调用，可以直接通过类名调用。这是因为它们属于类本身，而不是类的实例。 不能访问非静态成员：由于静态成员函数不依赖于具体的对象实例，它无法访问类的非静态成员（变量或函数），因为这些非静态成员需要对象实例来访问。 只能访问静态成员：静态成员函数只能访问类的静态成员变量或静态成员函数。 没有this指针：因为静态成员函数不属于任何对象实例，所以在静态成员函数内部没有this指针。 从下而上，从派生类的指针转换为多重基类的某一个指针，有什么问题。\noverride加与不加的区别\n一个类中的引用，会在什么时候初始化\n该引用成员必须在类的构造函数初始化列表中进行初始化。引用在C++中是必须被绑定到一个有效的对象或变量，因此它必须在对象创建时被初始化，且在对象的生命周期内不能再改变绑定的对象或变量。\n必须使用初始化列表：引用成员变量必须在构造函数的初始化列表中进行初始化，不能在构造函数体内进行初始化。这是因为引用在C++中一旦被绑定，就不能再更改绑定对象，所以它在对象创建时就必须得到初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; class MyClass { private: int\u0026amp; ref; // 引用成员变量 public: // 构造函数，使用初始化列表初始化引用成员 MyClass(int\u0026amp; r) : ref(r) { // 构造函数体内不能再次初始化ref } void show() { std::cout \u0026lt;\u0026lt; \u0026#34;Value of ref: \u0026#34; \u0026lt;\u0026lt; ref \u0026lt;\u0026lt; std::endl; } }; int main() { int x = 10; MyClass obj(x); // 在对象创建时初始化引用成员 obj.show(); // 输出: Value of ref: 10 return 0; } 引用成员的生命周期：引用成员的生命周期与包含它的对象的生命周期一致。引用成员会一直引用初始化时绑定的对象或变量，直到包含它的对象被销毁。\n初始化顺序：在C++中，成员变量的初始化顺序是根据它们在类中声明的顺序，而不是在初始化列表中的顺序。因此，即使在初始化列表中按不同顺序列出成员变量，实际的初始化顺序仍然是根据它们在类中的声明顺序来执行的。\n","date":"2024-08-14T21:46:21+08:00","permalink":"https://zeel210.github.io/p/c-%E6%8A%80%E6%9C%AFqa%E4%BA%8C/","title":"C++技术Q\u0026A（二）"},{"content":"C++技术Q\u0026amp;A（一）\r#include \u0026lt;xxx.h\u0026gt; 和 #include \u0026ldquo;xxx.h\u0026quot;有什么区别\n#include \u0026lt;xxx.h\u0026gt; 用于标准库头文件：通常用于包含标准库的头文件。\n搜索路径：编译器首先在标准库的目录中查找文件。这些目录通常是编译器安装时配置的目录。例如，在C++中，#include 会让编译器在其标准库路径中寻找 iostream 头文件。\n意图：这种形式表明你正在包含一个通用的、标准的或第三方库中的头文件。\n#include \u0026ldquo;xxx.h\u0026rdquo; 用于项目中的头文件：通常用于包含用户定义的头文件，即你在项目中创建的头文件。\n搜索路径： 编译器首先在当前源文件所在的目录查找文件。 如果在当前目录中找不到，编译器会在指定的包含路径中搜索（例如，使用 -I 选项指定的目录）。 最后，编译器可能会在标准库目录中查找，但这是实现定义的。\n意图：这种形式表明你正在包含一个与当前项目更紧密相关的头文件，通常是你自己编写的头文件。\n前者通常用于包含标准库的头文件。引用内容通常是一个通用的、标准的或第三方库的头文件。\n后者通常是引用我自己在项目中创建的头文件。它与项目的相关性更高。\nconst的用途\n可以定义一个常量变量，这个值在初始化之后不可修改。\nconst int* p ,不能通过指针修改他指向的值。\nint* const p,不能修改它指向的地址。\nvoid func(const int\u0026amp; i) 函数不可修改ｉ值，避免拷贝。\nint func() const{} 修饰类的成员函数，保证函数不会修改类里的成员变量。\nconst int func() 函数返回常量对象，调用者不能修改这个返回的常量对象的内容，同时这个对象也只能调用const函数。\nconst int func() const{} 调用者不可以通过该返回的引用修改原对象。\nconst int* func() 不能通过指针，修改原对象。\n总结：防止修改，明确意图，提高安全性。\nC++中调用C函数，为什么要加extern \u0026ldquo;C\u0026rdquo;？\n因为他们的函数名在编译后的符号表中有不同的命名规则。如果没有这个说明，c++ 代码无法直接链接调用c语言的函数。\n链接动态库时有一个函数未找到，该如何排查解决 ？\n库文件未正确链接 -lceres 函数名称不匹配 找不到正确的库所在的路径 库的版本不对 静态和动态链接混用 全局变量/函数 加不加static有什么区别?\n加了，具有内部链接属性，只在定义他们的文件内可见，其他文件不能用。可避免命名冲突。 不加，具有外部链接属性，可通过extern在多个文件中访问。 C++异常可以跨线程传播吗\n不能直接跨线程传播，可以通std::promise和std::future间接完成。\n构造函数里面是否可以调用虚函数\n可以调用虚函数，但可能不会表现出多态行为。\n#ifndef、#define、#endif的作用\n他们都是预处理指令， #ifndef用于检查某个宏是否未定义，如果没定义就执行。。。 #define用于定义一个宏，在头文件保护符中，通常用于定义一个唯一的宏。 #endif用于结束#ifndef的条件块。 用这一套东西，可以避免头文件的重复包含和类的重复定义。 虚函数和虚表有什么区别与联系\n虚表是一个指针数组，每个元素都是指向虚函数的指针。\n当通过基类指针或引用调用虚函数时，编译器会使用虚表指针查找实际函数的地址，然后调用该函数。\n这样就可以在运行时根据对象的实际类型调用正确的函数版本。\nc++几种继承方式?\n访问控制符protected：类内部和派生类能访问。\npublic inheritance\n基类的private成员，无法直接在派生类中访问。\nprotected inheritance\n在公有继承的基础上，基类的public和protected成员，在派生类中都变成了protected.\n这种继承方式限制了外部对象对派生类和基类成员的访问，但允许派生类的子类访问。\nprivate inheritance\n在公有继承的基础上，基类的public和protected成员，在派生类中都变成了private.\n多态有几种实现\n多态允许相同的操作以不同的方式执行。它有两种方式实现：\n静态多态，编译时多态 Function Overloading，同一个函数名可以有多个不同的实现，具体调用哪个函数由参数的类型和数量决定。 Operator Overloading，运算符可以被重载为自定义类型的操作，例如重载+运算符来实现两个对象的相加。 动态多态，运行时多态 Virtual Function，通过在基类中定义虚函数，并在派生类中重写它们，可以实现不同对象调用相同函数时表现出不同的行为。 Pure Virtual Function and Abstract Class，如果一个类包含一个或多个纯虚函数，那么这个类就是一个抽象类，不能直接实例化。派生类必须实现所有纯虚函数才能实例化。 map和unordered_map的差别，使用场景，底层数据结构\n差别：前者有序，后者无序。 底层结构：前者是红黑树，所有操作的时间复杂度为O(log n)。后者是哈希表，大多数操作的时间复杂度平均为O(1)，最坏情况下为O(n)。 内存使用：map通常比unordered_map使用更少的内存，因为它不需要额外的哈希表存储。由于哈希表的开销，unordered_map通常会使用更多的内存。 选择map: 当你需要有序的键值对时，或者你需要在键的顺序上进行复杂操作，比如范围查询，map是更合适的选择。 选择unordered_map: 当你不关心顺序而更关心操作的效率时，unordered_map通常会提供更好的性能，尤其是在处理大量数据时。 std::atmoic\nstd::atomic 是 C++ 标准库中的一个模板类，用于在多线程环境中实现原子操作。它保证了对变量的访问是线程安全的，即无论多少线程同时读写同一个 std::atomic 对象，都不会产生数据竞争。提供了对基本数据类型（如整数、指针等）的原子操作支持，避免了使用锁（如 std::mutex）带来的开销和复杂性。\n使用场景：\n并发计数器：多个线程同时对一个计数器进行加减操作时，使用 std::atomic 确保操作的原子性。 标志变量：在多线程应用中，使用 std::atomic 来标识某个状态或条件是否满足。 无锁数据结构：实现无锁队列、栈等数据结构时，使用 std::atomic 确保操作的安全性和高效性。 重载比较运算符\n一些设计上的规则：\n重载的比较运算符通常是const成员函数，因为它们不修改对象的状态。 通常应保持==与!=成对重载，\u0026lt;、\u0026gt;、\u0026lt;=、\u0026gt;=成对重载，以保证逻辑一致性。 可以通过重载其中一个运算符，再在其基础上实现其他运算符。例如，定义\u0026lt;后，可以通过\u0026lt;实现\u0026lt;=、\u0026gt;、\u0026gt;=。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; class Point { private: int x, y; public: Point(int x, int y) : x(x), y(y) {} // 重载 \u0026#34;==\u0026#34; 运算符 bool operator==(const Point\u0026amp; other) const { return (x == other.x) \u0026amp;\u0026amp; (y == other.y); } // 重载 \u0026#34;!=\u0026#34; 运算符 bool operator!=(const Point\u0026amp; other) const { return !(*this == other); } // 重载 \u0026#34;\u0026lt;\u0026#34; 运算符 (假设按x坐标优先排序) bool operator\u0026lt;(const Point\u0026amp; other) const { if (x \u0026lt; other.x) return true; if (x == other.x) return y \u0026lt; other.y; return false; } // 重载 \u0026#34;\u0026gt;\u0026#34; 运算符 bool operator\u0026gt;(const Point\u0026amp; other) const { return other \u0026lt; *this; } // 重载 \u0026#34;\u0026lt;=\u0026#34; 运算符 bool operator\u0026lt;=(const Point\u0026amp; other) const { return !(other \u0026lt; *this); } // 重载 \u0026#34;\u0026gt;=\u0026#34; 运算符 bool operator\u0026gt;=(const Point\u0026amp; other) const { return !(*this \u0026lt; other); } ","date":"2024-07-03T21:44:55+08:00","permalink":"https://zeel210.github.io/p/c-%E6%8A%80%E6%9C%AFqa%E4%B8%80/","title":"C++技术Q\u0026A（一）"},{"content":"C++ 11\rC++11 是 C++ 的一个重要版本，被称为 C++ 的“现代化”版本。它引入了大量的新特性，极大地提升了代码的简洁性、可维护性和性能。以下是 C++11 的一些主要特性和标准：\n1. 自动类型推导 (auto)\rC++11 引入了 auto 关键字，它可以根据变量初始化时的表达式自动推导类型。这减少了重复类型声明的冗余，特别是在使用复杂的模板时非常有用。\n1 2 auto x = 5; // 自动推导为 int auto y = 3.14; // 自动推导为 double 2. Lambda 表达式\rLambda 表达式是匿名函数，即没有名字的函数。它可以在代码中直接定义并作为参数传递，特别适合于简短的、一次性的函数使用场景。Lambda 表达式常用于算法、事件处理和并发编程中。\n1 2 auto sum = [](int a, int b) { return a + b; }; int result = sum(3, 4); // result = 7 c++14对Lambda有了一点更新，详见。\n3. nullptr\r在 C++11 中，引入了 nullptr 来替代旧的 NULL 宏，nullptr 表示一个空指针，其类型为 std::nullptr_t，更加类型安全。\n1 2 3 4 5 cpp 复制代码 int* p = nullptr; // 明确指定为空指针 4. constexpr\rconstexpr 允许在编译时执行常量表达式计算。使用 constexpr 修饰的函数和变量可以在编译期计算结果，从而提升运行时性能。\n1 2 3 4 cpp复制代码constexpr int square(int x) { return x * x; } constexpr int result = square(5); // 在编译时计算结果 5. 右值引用与移动语义 (rvalue reference and move semantics)\rC++11 引入了右值引用（\u0026amp;\u0026amp;），以及与之相关的移动语义，这使得资源的移动操作变得更加高效，避免了不必要的深拷贝，提升了性能，尤其在处理动态内存或大对象时。\n1 2 cpp复制代码std::vector\u0026lt;int\u0026gt; v1 = {1, 2, 3, 4}; std::vector\u0026lt;int\u0026gt; v2 = std::move(v1); // v1 的资源移动给 v2，避免了复制 6. std::move 和 std::forward\rstd::move 用于将左值强制转换为右值引用，允许资源被移动而不是复制。 std::forward 用于在模板中保持参数的左值或右值特性，通常在完美转发（perfect forwarding）中使用。 1 2 3 4 cpp复制代码template\u0026lt;typename T\u0026gt; void process(T\u0026amp;\u0026amp; arg) { doSomething(std::forward\u0026lt;T\u0026gt;(arg)); // 保留传递参数的左右值特性 } 7. std::unique_ptr 和 std::shared_ptr\rC++11 引入了智能指针 std::unique_ptr 和 std::shared_ptr，它们是 RAII（资源获取即初始化）模式的一部分，帮助自动管理动态内存资源，避免手动调用 delete，从而减少内存泄漏的风险。\nstd::unique_ptr：一个独占所有权的指针。 std::shared_ptr：一个引用计数的指针，多个对象可以共享所有权。 1 2 cpp复制代码std::unique_ptr\u0026lt;int\u0026gt; ptr1 = std::make_unique\u0026lt;int\u0026gt;(10); // 创建 unique_ptr std::shared_ptr\u0026lt;int\u0026gt; ptr2 = std::make_shared\u0026lt;int\u0026gt;(20); // 创建 shared_ptr 8. std::thread 和 多线程支持\rC++11 原生支持多线程编程，通过 std::thread 和相关的同步机制（如 std::mutex, std::condition_variable）让 C++ 的并发编程更加易用且标准化。\n1 2 3 4 5 cpp复制代码void threadFunc() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello from thread!\u0026#34; \u0026lt;\u0026lt; std::endl; } std::thread t(threadFunc); // 创建线程 t.join(); // 等待线程执行完毕 9. 范围 for 循环\rC++11 引入了基于范围的 for 循环，简化了对容器或数组元素的遍历。\n1 2 3 4 cpp复制代码std::vector\u0026lt;int\u0026gt; v = {1, 2, 3, 4}; for (int x : v) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出 1 2 3 4 } 10. 模板别名（using 别名）\rC++11 引入了 using 作为模板类型别名的语法糖，相比 typedef 更加直观且支持模板类型。\n1 2 3 cpp复制代码template \u0026lt;typename T\u0026gt; using Vec = std::vector\u0026lt;T\u0026gt;; // 使用 using 定义模板别名 Vec\u0026lt;int\u0026gt; myVec; // 相当于 std::vector\u0026lt;int\u0026gt; myVec; 11. enum class（强类型枚举）\rC++11 引入了 enum class（强类型枚举），使得枚举更加类型安全，避免了不同枚举类型之间的隐式转换。\n1 2 cpp复制代码enum class Color { Red, Green, Blue }; Color color = Color::Red; // 必须使用作用域来访问枚举值 12. std::array\rC++11 引入了 std::array，它是一个固定大小的数组，提供 STL 容器的接口，可以与标准库算法一起使用。\n1 2 3 4 5 cpp 复制代码 std::array\u0026lt;int, 3\u0026gt; arr = {1, 2, 3}; 13. 初始值列表（Initializer List）\rC++11 支持通过花括号 {} 进行列表初始化，并引入了 std::initializer_list 允许用户定义的类可以使用列表初始化。\n1 2 3 4 5 cpp 复制代码 std::vector\u0026lt;int\u0026gt; v = {1, 2, 3, 4}; // 列表初始化 14. 委托构造函数\rC++11 支持类的一个构造函数调用另一个构造函数，减少了重复代码。\n1 2 3 4 5 6 7 cpp复制代码class MyClass { public: MyClass(int x) : MyClass(x, 0) {} // 调用另一个构造函数 MyClass(int x, int y) : x(x), y(y) {} private: int x, y; }; 15. noexcept 关键字\rC++11 引入了 noexcept 关键字，用于标明某个函数不会抛出异常，帮助编译器优化代码。\n1 2 3 cpp复制代码void myFunc() noexcept { // 该函数不会抛出异常 } 16. 统一的初始化语法\rC++11 引入了一种新的统一初始化语法，使用花括号 {} 来初始化对象、数组、类成员等，简化了不同对象的初始化方式。\n1 2 cpp复制代码int x = {5}; // 等价于 int x = 5; std::vector\u0026lt;int\u0026gt; v{1, 2, 3}; // 初始化 vector 17. override 和 final 关键字\roverride：用于显式表明一个函数是重写基类中的虚函数，编译器会检查基类是否确实存在该虚函数，避免意外的错误。 final：用于禁止子类进一步重写某个虚函数。 1 2 3 4 5 6 cpp复制代码class Base { virtual void func() {} }; class Derived : public Base { void func() override {} // 显式声明重写基类函数 }; 18. std::tuple\rC++11 引入了 std::tuple，它是可以存储多个不同类型对象的容器，非常适合用于函数返回多个值。\n1 2 cpp复制代码std::tuple\u0026lt;int, double, std::string\u0026gt; myTuple(10, 3.14, \u0026#34;hello\u0026#34;); int i = std::get\u0026lt;0\u0026gt;(myTuple); // 获取 tuple 中的第一个元素 总结\rC++11 是现代 C++ 编程的基础，它引入了许多强大的新特性，使得编写更高效、更易维护的代码成为可能。这些特性也为后续的 C++14、C++17 以及 C++20 奠定了基础。\nC++ 14\r2. 返回类型推导（Return Type Deduction）\rC++14 允许函数的返回类型自动推导，不需要显式指定 -\u0026gt; decltype(auto)。编译器会根据函数体的返回值来推导类型。\n1 2 3 auto add(int a, int b) { return a + b; // 自动推导返回类型为 int } 3. 二进制字面量\rC++14 引入了 二进制字面量，可以直接在代码中使用 0b 或 0B 前缀来表示二进制数字。\n1 2 3 4 5 cpp 复制代码 int bin = 0b1010; // 二进制数 1010 表示十进制 10 4. 下划线数字分隔符\r在 C++14 中，可以使用下划线 _ 作为数字的分隔符，方便阅读长数字。它不影响实际的数值。\n1 2 3 4 5 cpp 复制代码 int million = 1\u0026#39;000\u0026#39;000; // 等同于 1000000 5. decltype(auto)\rdecltype(auto) 是一种推导类型的方式，它基于表达式的类型推导而返回具体类型。它比 auto 更加精确，可以保留引用类型和常量性。\n1 2 cpp复制代码int x = 10; decltype(auto) y = (x); // y 的类型为 int\u0026amp; ","date":"2024-07-02T19:20:18+08:00","permalink":"https://zeel210.github.io/p/c-11/14%E6%A0%87%E5%87%86/","title":"C++ 11/14标准"},{"content":"1. 什么是 Lambda 表达式？\rLambda 表达式是匿名函数，即没有名字的函数。它可以在代码中直接定义并作为参数传递，特别适合于简短的、一次性的函数使用场景。Lambda 表达式常用于算法、事件处理和并发编程中。\n2. Lambda 表达式的基本语法\rLambda 表达式的基本形式如下：\n1 2 3 [捕获列表] (参数列表) -\u0026gt; 返回类型 { 函数体 }; 捕获列表 [capture]：用于捕获作用域中的变量，决定 Lambda 对外部变量的访问方式。 参数列表 (parameters)：与普通函数的参数列表类似，可以指定参数的类型，也可以省略参数列表。 返回类型 -\u0026gt; return_type：可选，如果 Lambda 表达式的返回类型可以由编译器推导，则可以省略。 函数体 {body}：Lambda 的核心代码。 3. 捕获方式\rLambda 可以通过值或引用来捕获外部变量。\n按值捕获（[=]）：Lambda 表达式捕获外部作用域的变量时，创建它们的副本。Lambda 内部修改这些副本不会影响外部变量。 1 2 3 int x = 10; auto lambda = [=]() { return x + 1; }; // 按值捕获 x std::cout \u0026lt;\u0026lt; lambda(); // 输出 11，外部 x 不变 按引用捕获（[\u0026amp;]）：Lambda 表达式捕获外部作用域的变量时，引用它们的地址，内部对变量的修改会影响外部变量。 1 2 3 4 int x = 10; auto lambda = [\u0026amp;]() { x += 1; }; // 按引用捕获 x lambda(); std::cout \u0026lt;\u0026lt; x; // 输出 11，外部 x 被修改 显式捕获：可以指定捕获哪些变量，以及是按值还是按引用捕获。 1 2 3 4 int x = 10, y = 20; auto lambda = [x, \u0026amp;y]() { y = x + 1; }; // 按值捕获 x，按引用捕获 y lambda(); std::cout \u0026lt;\u0026lt; y; // 输出 11 4. Lambda 表达式的应用\rLambda 表达式广泛应用于 STL 算法、事件处理、回调等场景中。它可以使代码更加简洁和可读。\n1 2 3 4 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3, 4, 5}; std::for_each(vec.begin(), vec.end(), [](int x) { std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); // 输出 1 2 3 4 5 5. 捕获初始化（C++14 引入）\rC++14 允许在捕获列表中进行变量初始化，这使得 Lambda 可以捕获计算结果。\n1 2 3 int x = 10; auto lambda = [z = x + 1]() { return z; }; // 捕获 x + 1 的结果 std::cout \u0026lt;\u0026lt; lambda(); // 输出 11 constexpr\r1. 什么是 constexpr？\rconstexpr 关键字用于定义在编译时可确定其值的表达式或函数。与 const 不同，constexpr 不仅意味着值不变，还要求其值能够在编译时计算，这对于优化性能非常有用。\n2. constexpr 的用法\rconstexpr 变量：必须是编译时常量，其初始化值必须是常量表达式。 1 2 constexpr int size = 100; // 编译时常量 int arr[size]; // 可以使用编译时常量定义数组大小 constexpr 函数：允许函数在编译时执行运算。函数体中的所有操作都必须能够在编译时执行。 1 2 3 4 constexpr int square(int x) { return x * x; } constexpr int result = square(5); // 在编译时计算 result 3. constexpr 函数的特性\r在编译时求值：如果函数的参数是编译时常量，constexpr 函数会在编译时执行。 在运行时求值：如果参数不是编译时常量，constexpr 函数仍可以在运行时执行，表现得像普通函数。 1 2 int x = 10; int result = square(x); // 在运行时执行 4. constexpr 构造函数\rC++11 允许类的构造函数声明为 constexpr，这意味着该类可以用于编译时常量表达式。C++14 放宽了 constexpr 的限制，使得它可以包含更复杂的语句（如循环）。\n1 2 3 4 5 6 7 8 9 class Point { public: constexpr Point(int x, int y) : x_(x), y_(y) {} constexpr int getX() const { return x_; } private: int x_, y_; }; constexpr Point p(10, 20); // 在编译时创建 Point 对象 5. C++14 对 constexpr 的改进\rC++14 对 constexpr 进行了扩展，允许其包含更加复杂的控制结构，如条件判断和循环。这使得 constexpr 函数可以执行更加灵活的编译时运算。\n1 2 3 4 5 6 7 8 constexpr int factorial(int n) { int result = 1; for (int i = 1; i \u0026lt;= n; ++i) { result *= i; } return result; } constexpr int fact = factorial(5); // 在编译时计算阶乘 6. constexpr 与性能优化\r使用 constexpr 的好处在于能够将计算提前到编译时执行，从而提升程序的运行时性能，尤其在需要频繁计算的场景下，如图形学、物理仿真等。\n7. **什么时候不能用constexpr **\r可以使用 constexpr 的情况：\r函数体中的所有操作都可以在编译时完成。 参数是常量或者可以在编译时确定。 没有涉及动态内存分配、I/O 操作、异常处理等运行时依赖。 函数返回一个能够在编译时确定的结果。 不能使用 constexpr 的情况：\r函数中使用了动态内存分配、I/O 操作、异常处理等运行时依赖。 函数的返回值依赖于运行时输入或计算。 C++11 中，递归深度过深的函数不能使用 constexpr（C++14 及之后的版本放宽了限制）。 正确使用 constexpr 可以大幅提升代码性能，尤其是在需要大量重复计算时，通过在编译时完成这些计算来减少运行时的开销。\n总结\rLambda 表达式 提供了一种方便、简洁的匿名函数定义方式，尤其适用于需要将函数作为参数传递的场景（如算法、回调等）。 constexpr 允许在编译时进行计算，对于性能优化非常有帮助。它通过要求编译期常量计算，减少了运行时的计算开销，尤其适用于高性能应用。 ","date":"2024-07-02T17:22:18+08:00","permalink":"https://zeel210.github.io/p/c-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8Econstexpr/","title":"C++ lambda表达式与constexpr"},{"content":"现象\r能够表示相机外参计算精确度的相机重投影误差，一直与它们的理想值之间有着很夸张的差距。\n拥有一套好的外参的相机的重投影误差，一般小于10，并接近0。但现在的误差最大能达到10的五十次方。。。\n排查方向\r重投影误差本身的有效性\r这套代码起初我在23年写的，写好后给到佳朋，集成进991来给首钢园做标定，很少出现误差值异常夸张的情况。mscalib用的正是这套外参计算代码。 用三个录制的标定视频作为输入，用mscalib能得到数值几乎与用python标定代码结果一样的准确外参，更排除了这个可能。 外参计算代码是否被我不经意改过\r仔细核查流程的每个可能出错的地方后，用三段好的标定视频能够标定出精准的外参，也排除了这个可能。\n标定杆的点检测逻辑是否有漏洞或缺陷\rMscalib能检测到的有效特征点的数量不是影响标定的因素，用视频检测出的稀疏化后的特征点为5000左右时，也能标定出好结果。而MSCalib检测出的12000个点，效果同样不好。 检测帧率和检出效率都没问题，因为同样的时间内，检出的特征点数量并不少。我甚至把检测参数的一部分回调为佳朋在991中的检测参数，同样不起作用。用录制好的视频做测试，也没有问题。 经过检查，发现标定杆上五个特征点的顺序在保存时排错了，改正这个问题后问题依旧存在。 也怀疑是否是点检测保存下来的点坐标值在被读取时发生异常，比如把保留了两位数字的浮点数读取异常。 检测数据与外参标定需要的个数不一致\r曾狠狠怀疑我保存检测数据的文本文件的数据格式是否有问题，但是将它们与好的标定数据做对比后，发现没有问题。 点检测结果是否有效？\r将检测点全部绘制到画布中，发现点的分布在肉眼上没有问题。 利用记录有检测数据的文本文件，把检测点绘制成动画，简单观察它们是否与预期一致，比如是否有基本的同步性，或者是否有卡顿或检测异常的情况。但还没有发现问题。它们的表现与录制视频中检测到的点的表现肉眼看不出区别。 最终问题所在\r在高速写文件的时候，用out\u0026lt;\u0026lt;point_x\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;point_y\u0026lt;\u0026lt;\u0026quot; \u0026quot;;的方式，会出现这个写异常问题。而每次只写入一个坐标分量，就没有这个问题。\n","date":"2024-06-15T21:24:18+08:00","permalink":"https://zeel210.github.io/p/%E4%B8%80%E6%AC%A1%E5%A4%9A%E7%9B%B8%E6%9C%BA%E5%A4%96%E5%8F%82%E6%A0%87%E5%AE%9A%E5%BC%82%E5%B8%B8%E7%BB%93%E6%9E%9C%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B/","title":"一次多相机外参标定异常结果问题排查过程"},{"content":"方案A技术原理概述\r通过手动粘贴与测量，获取投影面上所有Aruco二维码的ID，与二维码中心点的二维物理坐标的对应关系。 借助高精度相机和格雷码结构光技术，估计出每个二维码中心点在投影画面中的二维像素坐标。 利用每个二维码的ID，建立每个二维码中心点的二维物理坐标和投影仪二维像素坐标的匹配关系。再利用这些离散的匹配关系，通过插值，构造目标平面上投影仪坐标系中每个点与物理平面坐标的对应关系。 这样，不同的投影仪画面都与同一个物理平面做了匹配。假设有一幅图像需要两个投影仪共同投射，每台投影仪只需要知道这幅图像的某个像素Pixel对应在物理平面上是哪一点，就可以用它的某个像素,来投射这幅图像的这一像素Pixel。因此，图像上的每个像素点，只会被不同投影仪投射到物理平面上唯一的一个位置，投影融合就完成了。 方案设计B——Aruco二维码+三维重建\r与方案A的重要区别\r在方案A中，投影平面上的二维码的物理位置由人工测量获取，同时它们在投影仪画面中的像素位置，是借助结构光直接或间接估算出来的。\n在方案B中，二维码由投影仪直接投射到投影平面上，这个方法直接省去了人工粘贴二维码的操作。而这样一来，它们在投影仪画面中的像素位置就变成了已知量，它们的物理位置变成了未知量。\n因此，新方案重新设计了一套基于三维重建的坐标匹配方法，来计算每个二维码中心点在物理坐标系中的位置。\n区别 旧方案 新方案1 二维码中心点物理位置 人工粘贴并测量 三维重建，计算得到 二维码中心点投影像素位置 结构光，计算得到 投影仪投射，位置已知 投影ROI边界约束方法 在ROI边界处粘贴二维码约束 在ROI边界处粘贴圆形锚点约束 目标对象 单个投影面 五个投影面在内的整个场地 方案B流程\r给场地中每个投影面的四个顶点处粘贴上红色marker点，相邻平面的共同顶点共用一个marker点（锚点）。测量并定义每个锚点在物理空间P（世界坐标系）中的位置，用集合表示。 给场地内所有投影仪都准备一张二维码阵列图像。每个二维码的id唯一且已知，它们在图像中的像素位置已知，记为。 将一台已完成标定的高分辨率相机用三脚架固定在场地中，不断调整它的位置和朝向Pose，使它的FOV能覆盖到场地上所有锚点和二维码。每调整一次Pose，让相机当前FOV中所有投影区域所负责的投影仪，依次投射自己的二维码图像（保证不同投影仪的二维码不重叠），同时相机拍摄一张照片。调整相机的Pose时，应确保相机拍摄的照片符合三维重建要求。 利用相机照片中场地所有锚点和二维码中心点（码点）信息，对场地五个投影面（四周和地面）进行三维重建：获取所有锚点和码点在虚拟空间坐标系V中的位置，用集合，表示。 进行坐标系变换。根据和的对应关系，利用相似变换（or 刚体、仿射变换，找一个最合适的），求得码点在世界坐标系P中的位置。 对于每一个投影平面，都利用这个平面上的锚点在P中的坐标，计算出这个平面在P中的平面方程。再计算所有码点坐标，在它们所属平面上的投影。 利用码点在各自投影仪的二维坐标，和他们在坐标系P中的平面投影坐标的映射关系，估计出锚点在每个投影仪的二维坐标（锚点的是已知的，见1）。 利用(,)，(,)匹配关系，用插值法计算出目标平面上投影仪坐标系中每个点与物理平面坐标的对应关系。 第7步得到的数据在形式上跟旧方案的数据是一致的，有了匹配关系后，回到旧方案的最后步骤，完成投影仪融合。 可能存在的问题\r一个物理投影面边界处的点在投影仪坐标系中的位置是无法直接获取的，而是通过和的匹配关系估计出来的。为了保证边界处匹配关系的精度，就应该存在一些投影仪投射的二维码，尽可能贴近物理投影平面的边界处。 误差的累计可能会让投影面交界处的融合精度很差，出现画面对不齐的情况。两个相邻投影平面中，投影仪坐标和物理平面坐标的匹配关系，可能在两个平面交界处无法保持均匀的统一。即两个平面上统一的信息只有交界处上下方两个锚点，有限的信息可能无法约束中间远离锚点的边界处的画面的统一性。 因此，基于二维码的新方案的顺利运行，就需要每个投影仪有能力在自己负责的投影面的边缘处，投射出可被识别的二维码，这个功能可能需要人工介入，或需要复杂的设计。\n方案C设计——格雷码+三维重建\r• 与方案B不同的是，此方案利用格雷码来重建三维点云，进而完成不同坐标系的匹配。\n• 利用格雷码结构光技术，结合相机多视角三维重建，我们可以获取大量的投影仪坐标系与物理平面坐标系的对应关系，这样的对应关系在本质上跟Aruco二维码提供的信息是一致的。除了重建三维点云的方法从二维码变为格雷码结构光外，其他步骤是一样的。\n• 但区别就在于，这个方案能获取的有效匹配点更稠密，在投影平面边界处能提供更多的有效信息，来提高估计出来的投影面顶点的投影仪像素坐标的精度。同时，投影仪画面投射在自己负责的投影面之外的区域，也能帮助提高三维重建和坐标匹配的精度。\n• 这个方案的一个已知缺点是，执行耗时较长。因为每固定一个相机机位，相机FOV内的所有投影仪都要投射数量较大的光栅图。还因为结构光技术的数据量较大，处理时间长。\n","date":"2024-04-11T20:01:28+08:00","permalink":"https://zeel210.github.io/p/%E5%A4%9A%E6%8A%95%E5%BD%B1%E4%BB%AA%E8%87%AA%E5%8A%A8%E5%8C%96%E8%9E%8D%E5%90%88%E6%80%9D%E8%B7%AF/","title":"多投影仪自动化融合思路"},{"content":"ros2发布订阅\n创建包 进入工作空间src目录\nBash ros2 pkg create \u0026ndash;build-type ament_cmake cpp_pubsub\n创建用于发布话题的cpp 使用继承模式创建节点并定时发送消息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;chrono\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;std_msgs/msg/string.hpp\u0026#34; using namespace std::chrono_literals; /* This example creates a subclass of Node and uses std::bind() to register a * member function as a callback from the timer. */ class MinimalPublisher : public rclcpp::Node { public: MinimalPublisher() : Node(\u0026#34;minimal_publisher\u0026#34;), count_(0) { publisher_ = this-\u0026gt;create_publisher\u0026lt;std_msgs::msg::String\u0026gt;(\u0026#34;topic\u0026#34;, 10); timer_ = this-\u0026gt;create_wall_timer( 500ms, std::bind(\u0026amp;MinimalPublisher::timer_callback, this)); } private: void timer_callback() { auto message = std_msgs::msg::String(); message.data = \u0026#34;Hello, world! \u0026#34; + std::to_string(count_++); RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;Publishing: \u0026#39;%s\u0026#39;\u0026#34;, message.data.c_str()); publisher_-\u0026gt;publish(message); } rclcpp::TimerBase::SharedPtr timer_; rclcpp::Publisher\u0026lt;std_msgs::msg::String\u0026gt;::SharedPtr publisher_; size_t count_; }; int main(int argc, char *argv[]) { rclcpp::init(argc, argv); rclcpp::spin(std::make_shared\u0026lt;MinimalPublisher\u0026gt;()); rclcpp::shutdown(); return 0; } 在上面代码中，创建继承自rclcpp::Node的MinimalPublisher类，在此类的构造函数中分别创建发布者和定时器，使用定时器每500ms定时执行一次timer_callback函数，在此函数中执行一次消息的发布，RCLCPP_INFO宏负责完成将log信息写入控制台，此消息可在rqt_console中看到\nrclcpp::spin(node)会让程序进入一个循环，处理所有待处理的回调，直到ROS被关闭或者节点被销毁。在这个循环中，程序会一直检查是否有新的回调需要处理，并处理它们。如果没有待处理的回调，程序会阻塞，直到有新的回调需要处理。\n​\t2. 直接在main函数中发送消息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;std_msgs/msg/string.hpp\u0026#34; int main(int argc, char *argv[]) { rclcpp::init(argc, argv); auto node = rclcpp::Node::make_shared(\u0026#34;publisher\u0026#34;); auto publisher = node-\u0026gt;create_publisher\u0026lt;std_msgs::msg::String\u0026gt;(\u0026#34;my_publish\u0026#34;, 10); auto count = 0; rclcpp::WallRate rate(1.0); // 1Hz while (rclcpp::ok()) { auto message = std_msgs::msg::String(); message.data = \u0026#34;Hello World \u0026#34; + std::to_string(count++); RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;Publishing: \u0026#39;%s\u0026#39;\u0026#34;, message.data.c_str()); publisher-\u0026gt;publish(message); rclcpp::spin_some(node); rate.sleep(); } rclcpp::shutdown(); return 0; } 此方法采取了一种更为传统的方式，首先创建节点publisher，然后创建话题my_publish，后使用循环发送消息。\nrclcpp::spin_some(node)它的作用是处理节点中待处理的一部分回调，如果不添加此语句，此节点将无法处理订阅者的回调，也就是订阅者无法工作，此方法将不会阻塞\n将相关依赖加入camke 以将2.1中代码为例写入src/cpp_pubsub/src/publisher_member_function.cpp中，然后将此文件及其依赖加入/home/xiejiapeng/dev_ws/src/cpp_pubsub/CMakeLists.txt中\n添加ros2相关依赖：\n1 find_package(rclcpp REQUIRED) find_package(std_msgs REQUIRED) 添加可执行文件：\n1 add_executable(publisher src/publisher_member_function.cpp) 指定目标（一个库或可执行文件）依赖项：\n1 ament_target_dependencies(publisher rclcpp std_msgs) 完整CMakeLists.txt\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 cmake_minimum_required(VERSION 3.5) project(cpp_pubsub) # Default to C++14 if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 14) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \u0026#34;Clang\u0026#34;) add_compile_options(-Wall -Wextra -Wpedantic) endif() find_package(ament_cmake REQUIRED) find_package(rclcpp REQUIRED) find_package(std_msgs REQUIRED) add_executable(talker src/publisher_member_function.cpp) ament_target_dependencies(talker rclcpp std_msgs) install(TARGETS talker DESTINATION lib/${PROJECT_NAME}) ament_package() 创建用于订阅话题的cpp 使用继承模式创建节点** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;memory\u0026gt; #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;std_msgs/msg/string.hpp\u0026#34; using std::placeholders::_1; class MinimalSubscriber : public rclcpp::Node { public: MinimalSubscriber() : Node(\u0026#34;minimal_subscriber\u0026#34;) { subscription_ = this-\u0026gt;create_subscription\u0026lt;std_msgs::msg::String\u0026gt;( \u0026#34;topic\u0026#34;, 10, std::bind(\u0026amp;MinimalSubscriber::topic_callback, this, _1)); } private: void topic_callback(const std_msgs::msg::String::SharedPtr msg) const { RCLCPP_INFO(this-\u0026gt;get_logger(), \u0026#34;I heard: \u0026#39;%s\u0026#39;\u0026#34;, msg-\u0026gt;data.c_str()); } rclcpp::Subscription\u0026lt;std_msgs::msg::String\u0026gt;::SharedPtr subscription_; }; int main(int argc, char *argv[]) { rclcpp::init(argc, argv); rclcpp::spin(std::make_shared\u0026lt;MinimalSubscriber\u0026gt;()); rclcpp::shutdown(); return 0; } ​\t2. 直接在main函数中订阅\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026#34;rclcpp/rclcpp.hpp\u0026#34; #include \u0026#34;std_msgs/msg/string.hpp\u0026#34; void message_callback(const std_msgs::msg::String::SharedPtr msg) { RCLCPP_INFO(rclcpp::get_logger(\u0026#34;rclcpp\u0026#34;), \u0026#34;I heard: \u0026#39;%s\u0026#39;\u0026#34;, msg-\u0026gt;data.c_str()); } int main(int argc, char * argv[]) { rclcpp::init(argc, argv); auto node = rclcpp::Node::make_shared(\u0026#34;my_subscriber\u0026#34;); auto subscriber = node-\u0026gt;create_subscription\u0026lt;std_msgs::msg::String\u0026gt;(\u0026#34;my_publish\u0026#34;, 10, message_callback); RCLCPP_INFO(node-\u0026gt;get_logger(), \u0026#34;Waiting for messages...\u0026#34;); rclcpp::spin(node); rclcpp::shutdown(); return 0; } ","date":"2023-10-13T22:34:28+08:00","permalink":"https://zeel210.github.io/p/ros2-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","title":"Ros2 发布订阅"},{"content":"话题相关命令\r查看话题列表 1 ros2 topic list 查看带类型的话题列表 1 ros2 topic list -t 在终端预览话题内容 1 ros2 topic echo \u0026lt;topic_name\u0026gt; 使用命令发布消息 1 ros2 topic pub \u0026lt;topic_name\u0026gt; \u0026lt;msg_type\u0026gt; \u0026#39;\u0026lt;args\u0026gt;\u0026#39; eg：\n发送一次\n1 ros2 topic pub --once /turtle1/cmd_vel geometry_msgs/msg/Twist \u0026#34;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\u0026#34; 循环发送：\n\u0026ndash;rate 后面参数为频率（次/秒）\n1 ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \u0026#34;{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\u0026#34; ​\t1.5 查看话题发布频率\n1 ros2 topic hz /turtle1/pose 类型相关命令\r查看类型定义\n1 ros2 interface show \u0026lt;msg type\u0026gt; eg：\n1 ros2 interface show geometry_msgs/msg/Twist 服务相关命令\r查看服务列表 1 ros2 service list 查看服务类型 查看单个：\n1 ros2 service type \u0026lt;service_name\u0026gt; 如果返回“std_srvs/srv/Empty”代表服务调用在发出请求时不发送任何数据\n查看全部：\n1 ros2 service list -t 服务查找 依据服务类型进行查找\n1 ros2 service find \u0026lt;type_name\u0026gt; 查看服务类型定义 1 ros2 interface show \u0026lt;type_name\u0026gt;.srv 使用命令调用服务在做此项操作前需先知道什么是服务类型，如何找到服务的类型，以及如何找到该类型参数的结构 调用服务：\n1 ros2 service call \u0026lt;service_name\u0026gt; \u0026lt;service_type\u0026gt; \u0026lt;arguments\u0026gt; eg:\n参数类型为std_srvs/srv/Empty可省略参数：\n首先Empty 类型化服务没有任何参数，此命令将清除海龟绘制的任何线条的turtlesim窗口\n1 ros2 service call /clear std_srvs/srv/Empty 调用带有参数的服务：\n新加入一只海龟，执行此操作后不会添加新的节点，而是会在所操作的节点上增加新的话题，新的服务\n1 ros2 service call /spawn turtlesim/srv/Spawn \u0026#34;{x: 2, y: 2, theta: 0.2, name: \u0026#39;\u0026#39;}\u0026#34; 注意：上文中“x: 2”间的空格不可少\n参数相关命令\r查看参数列表 1 ros2 param list 获取参数 1 ros2 param get \u0026lt;node_name\u0026gt; \u0026lt;parameter_name\u0026gt; eg:\n1 ros2 param get /turtlesim background_g 设置参数 1 ros2 param set \u0026lt;node_name\u0026gt; \u0026lt;parameter_name\u0026gt; \u0026lt;value\u0026gt; eg:\n1 ros2 param set /turtlesim background_r 150 使用 set 命令设置参数只会在当前会话中更改它们，而不会永久更改。但是，您可以保存设置并在下次启动节点时重新加载它们。\n参数转储 1 ros2 param dump \u0026lt;node_name\u0026gt; eg:\n1 ros2 param dump /turtlesim 存储的同时设置保存路径：\n1 ros2 param dump \u0026lt;node_name\u0026gt; --output-dir \u0026lt;OUTPUT_DIR\u0026gt; eg\n1 ros2 param dump /turtlesim --output-dir /media/xiejiapeng/jpx/ 参数加载 此方法会将参数加载到正在运行的节点\n1 ros2 param load \u0026lt;node_name\u0026gt; \u0026lt;parameter_file\u0026gt; eg:\n1 ros2 param load /turtlesim ./turtlesim.yaml 节点启动时加载参数文件 1 ros2 run \u0026lt;package_name\u0026gt; \u0026lt;executable_name\u0026gt; --ros-args --params-file \u0026lt;file_name\u0026gt; eg:\n1 ros2 run turtlesim turtlesim_node --ros-args --params-file ./turtlesim.yaml 动作相关命令\rAction是建立在话题和服务之上的。它们的功能与服务类似，除了动作是可抢占的 (您可以在执行时取消它们)。他们也提供稳定的反馈，而不是返回单一响应的服务。\nAction使用客户端-服务器模型，类似于出版商-订户模型 (在 topics tutorial 中描述)。“动作客户端” 节点向 “动作服务器” 节点发送目标，该节点确认目标并返回反馈流和结果。\n查看动作列表 查看带类型的动作列表\n1 ros2 action list -t 查看动作类型结构 1 ros2 interface show \u0026lt;action_type\u0026gt; eg：\n1 ros2 interface show turtlesim/action/RotateAbsolute 将返回：\n/RotateAbsolute # The desired heading in radians float32 theta \u0026mdash; # The angular displacement in radians to the starting position float32 delta \u0026mdash; # The remaining rotation in radians float32 remaining\n此消息的第一部分，在 \u0026mdash; 上方，是目标请求的结构 (数据类型和名称)。下一节是结果的结构。最后一节是反馈的结构。\n发送动作目标 不带实时反馈，仅带目标和结果\n1 ros2 action send_goal \u0026lt;action_name\u0026gt; \u0026lt;action_type\u0026gt; \u0026lt;values\u0026gt; eg:\n1 ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \u0026#34;{theta: 1.57}\u0026#34; 携带实时反馈，反馈剩余待完成内容，需要在上文基础上添加“ \u0026ndash;feedback”\n1 ros2 action send_goal \u0026lt;action_name\u0026gt; \u0026lt;action_type\u0026gt; \u0026lt;values\u0026gt; --feedback eg:\n1 ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \u0026#34;{theta: -1.57}\u0026#34; --feedback 终端将返回消息:\nSending goal: theta: -1.57Goal accepted with ID: e6092c831f994afda92f0086f220da27Feedback: remaining: -3.1268222332000732Feedback: remaining: -3.1108222007751465…Result: delta: 3.1200008392333984Goal finished with status: SUCCEEDED\ngoal为旋转的目标弧度（目标结果），Feedback为对剩余弧度（剩余动作内容）的实时反馈，Result为最终运动弧度（实际动作内容）\n图形化相关命令\rrqt 一个多功能的图形化调试应用。\n启动：\n1 rqt 第一次运行rqt后，窗口将为空白此时需从顶部的菜单栏中选择 插件\u0026gt; 服务\u0026gt;调用服务（Plugins \u0026gt; Services \u0026gt; Service Caller ）。\nrqt_graph 重点用于查看话题和节点之间的发布订阅关系\n启动：\n1 rqt_graph rqt_console 用于查看ros的系统日志\n启动：\n1 ros2 run rqt_console rqt_console 程序运行命令\r运行程序 1 ros2 run \u0026lt;package_name\u0026gt; \u0026lt;executable_name\u0026gt; eg:\n1 ros2 run turtlesim turtle_teleop_key 重映射 将默认节点属性 (如节点名称、话题名称、服务名称等) 重新分配给自定义值\n重映射节点名称示例：\n\u0026ndash;ros-args \u0026ndash;remap 可省略\n1 ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle 同时重映射发布或订阅的话题名和节点名示例：\n1 ros2 run turtlesim turtle_teleop_key /turtle1/cmd_vel:=/my_turtle/cmd_vel __node:=my_key 或者\n1 ros2 run turtlesim turtle_teleop_key --ros-args --remap /turtle1/cmd_vel:=/my_turtle/cmd_vel --remap __node:=my_key ","date":"2023-10-05T17:23:28+08:00","permalink":"https://zeel210.github.io/p/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%91%BD%E4%BB%A4/","title":"常用调试工具与命令"},{"content":"相机外参检查与校正\r思路1：利用场地中固定标记点\r将标记点固定在场地中，用标定杆完成初始外参标定后，所有相机拍摄一张场地照片。\n每次自检时，各相机再拍摄一张照片，对比两张照片中标记点的位置，进行外参检查与校正。\n标记点放置位置：\na. 地面或墙壁幕布上。\nb. 地面和墙壁幕布边缘交界处。\n标记点类型：\na. 反光贴。淘宝上有红外反光贴，但是没找到只反射红外光不反射可见光的贴。\nb. led灯。如何设计：电池供电独立开关？布线供电统一开关？是否影响游戏使用体验？\n标记点个数：\na. 两个：数量较小，只能做外参异常检测，做不到校正。\nb. 每个相机至少看到三个非共线点：可以校正，但精度未知。会让每个场景标记点的布置变得复杂。\n思路2：利用场景本身的特征点\r将标记点固定在场地中，用标定杆完成初始外参标定后，所有相机拍摄一张场地照片。\n每次自检时，各相机再拍摄一张照片。\n利用角点提取算法提取两张照片中的特征点，做匹配，根据匹配关系进行外参检查与校正。\n在实际场景中的可行性和鲁棒性有待探索（公司的项目场景中红外画面纹理太少了，提取不了特征）。\n网上有可供参考的特征点相机自标定资料。\n现可用来测试的场地照片不多。如果有了可供测试的照片样本，可在一周内完成可行性测试。\n思路3：其他基于场景本身的方法\r光流估计：光流是一种用于估计图像中像素在两个时间点之间的运动的技术。它可以用来估计相机的位移。OpenCV提供了用于计算光流的函数。只能检查不能校准。 直接法：直接法通过将两张图像的灰度值差异建模为相机运动的约束来估计相机的运动。它不依赖于特征点匹配，对于低文本纹理的场景也有效。 当相机移动位置较大，场景布置区别较大时，会失效。\n缺少照片样本来做测试。\n思路4：相机+IMU\r对这种模式了解不多，但网上能找到相关的成熟的方案资料。可行性验证时间未知。\n不能保证在相机的偏移十分缓慢时，imu仍能发挥作用。\n思路5：利用场景中人体骨骼信息\r当认为有个别相机的外参有偏移时，可以在场地中进个人，利用其骨骼信息，校正相机外参。\n现已完成了一项测试：利用一个人的骨骼信息校正一台外参明显偏移的相机，效果还行，但没有达到很理想的状态。\n需要测试这样的精度对 骨骼融合的影响，并继续尝试提高精度。\n缺点：很难检测某一台相机外参的偏移，目前只能进行校正。需要人的参与。\n可在2周内完成可行性测试。\n初始外参标定过程优化\r本次在首钢的标定过程中，遇到的所有问题、麻烦，几乎都是由相机分辨率不一致，或更换相机造成的。在这两个操作后，需要手动更换991系统的中参数文件或重启设备，才能正常标定，但这些操作很难通过优化程序来解决。\n对外确定世界坐标系位置的方法\r当场地中不允许粘贴胶带，来标记坐标系位置时，我们在标定后是否可以提供坐标系位置和方向在相机上的重投影坐标，来表示坐标系在场地中的实际位置？\n","date":"2023-08-05T23:34:28+08:00","permalink":"https://zeel210.github.io/p/%E5%A4%9A%E7%9B%B8%E6%9C%BA%E5%A4%96%E5%8F%82%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/","title":"多相机外参问题思考"},{"content":"自己的定义\r几何相机标定（Geometric Camera Calibration），简称相机标定（Camera Calibration），在英文中也称**“Camera Resectioning”，是一个根据给定的照片或视频，计算估计出相机模型的几何参数的过程。**这些几何参数描述了物体从三维世界到成像平面上各坐标点的对应关系。在计算机视觉领域，这些标定得到的参数可以用来校正镜头失真，以世界单位测量物体的大小，或确定相机在场景中的位置等。在我们的项目中，相机标定的结果主要用于三维场景重建。\n相机标定的通俗解释\r如前文所言，相机标定是一个确定特定相机几何参数的过程，以便让相机有能力完成一些特定的精确的操作。如果没有标定，相机的几何参数是未知的，或不精确的。我们拍摄了一张照片，却无法用照片来做我们想做的事：我们的计算机不知道如何处理它来去除畸变，不知道如何测量图像中某物体的真正尺寸，等等。我们可以用等式来ji近似描述这个过程，这里x是输入，y是输出，a是相机的几何参数。那么，相机标定的思路，就是“利用多组(x,y)对，建立一个方程组，来求取这组未知量a”。\n相机的光学成像，是一个将三维世界转换成二维图像的过程。因此我们将三维世界物体表面点的坐标作为输入，二维图像作为输出，来估算出一个可描述相机真实状态的“数学模型”。计算机利用这个相机模型，就可以进行特定的精确操作。\n相机成像模型\r众所周知，一般的相机由一组透镜和感光元件组成，利用透镜成像原理在感光元件上捕获图像。但相机的透镜成像模型较为复杂，涉及到透镜的形状、曲率、畸变等复杂光学性质，这给我们利用三维场景与二维照片来求取相机模型参数带来了困难。不过，我们在标定时关注的只是相机的投影几何关系，而可以忽略透镜的复杂光学成像过程，因此，小孔成像模型通常被用来替换透镜成像模型来计算相机的参数。但小孔成像模型是一种理想化的模型，光线通过一个小孔后直线传播，不发生折射和畸变，没有能力描述相机中的透镜畸变问题。因此，为了准确模拟真实的相机（这里不考虑视场角大于195度的鱼眼相机），一般的相机标定模型包括一个小孔成像模型和径向、切向镜头畸变。\n在小孔成像模型中，光线穿过小孔，在相机的另一侧投射出一个倒立的图像。这样，虚像平面位于相机前面，包含了场景的颠倒图像。那么，为了构建相机成像模型，估算相机几何参数，就需要用数学语言描述小孔成像的过程，这个过程涉及到了四个坐标系。\n四个坐标系\r• 世界坐标系：用户定义的三维世界的坐标系，用来描述目标物在真实世界里的位置以及相机所在的位置。原点和方向可以任意设置。\n• 相机坐标系：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。通常以相机的光心为坐标原点，x轴和y轴平行于图像坐标系的x轴和y轴，z轴为相机的光轴。\n• 图像坐标系：为了描述成像过程中物体从相机坐标系到图像坐标系的投影投射关系而引入 ，方便进一步得到像素坐标系下的坐标。与成像平面重合，以成像平面的中心（光轴与成像平面的交点）为坐标原点，x 轴和 y轴分别平行于成像平面的两条边。\n• 像素坐标系：用来描述物体成像后的像点在数字图像上（相片）的坐标，以像素个数为单位，是我们真正从相机内读取到的信息所在的坐标系。与成像平面重合，以成像平面的左上角顶点为原点，x 轴和 y 轴分别平行于图像坐标系的x轴和y轴。\n接下来我们用这个四个坐标系来描述世界中物体表面的一点在相机上成像的过程，记该点的坐标：\n世界坐标系：(Xw,Yw,Zw)\n相机坐标系： (Xc,Yc,Zc)\n图像坐标系：(x,y)\n像素坐标系：(u,v)\n世界坐标系到相机坐标系（相机外参）\r有了世界坐标系，我们首先知道了物体表面一点P的位置(Xw,Yw,Zw)。为了知道这一点相对于相机的空间位置，就需要做从世界坐标系到相机坐标系的刚体变换。引入齐次坐标，求取世界坐标系相对相机坐标系的旋转矩阵R和平移向量T，就可以将点转换到相机坐标系下：\n矩阵我们称为相机外参。其中 R 为 3×3 的正交阵,向量 t 表示 3×1 的三维平移量。\n相机坐标系到像素坐标系（相机内参）\r相机坐标系到图像坐标系 对于三维相机坐标系中的一点 Pc,其对应在成像平面上的成像点，是 Pc 与光心 O 的连线与图像平面的交点 p。又有相机焦距 f 。根据三角形相似定理可以推出相机坐标系与图像坐标的关系满足以下关系:\n写成齐次坐标的矩阵形式：\n图像坐标系到像素坐标系 图像坐标系下的坐标，依然是以“米”为单位的连续量。与它不同，像素坐标系以一个像素(pixel)为单位，原点在图像的左上方，u轴向右，v轴向下。假设是相机光心（图像坐标系原点）对应的像素坐标，某个像素点p坐标为(u,v)，dx和dy表示图像中每个像素在成像平面中的物理尺寸。则像素坐标系与成像平面坐标系之间有如下转换公式：\n综合上述公式，就得到了从世界坐标系到像素坐标系的转换公式：\n其中fx = f/dx,fy = f/dy。记\n​ 那么这里矩阵M表示从世界坐标系到像素坐标系的投影映射，一般称为相机矩阵(Camera Matrix)。K就是相机内部矩阵，K中的参数就是相机内参(Intrinsic Parameters)，RT称作相机外部矩阵，它本身也就是相机外参(Extrinsic Parameters)。\n小孔相机参数的物理意义\r经过上面的推导，我们就可以知道相机内外参的物理意义了。\n对于内参K，有更一般的形式\n其中fx = f/dx,fy = f/dy，f是物理世界下的相机焦距，dx与dy是图像中每个像素在成像平面中的物理尺寸，那么fx，fy就是相机以像素为单位在两个方向上的焦距。u0和v0代表相机光心（图像坐标系原点）的像素坐标。这里的γ是像素倾斜系数，一般情况为0。当γ不为零时，表示相机感光片上像素的排列方向没有垂直，有：\n则。推导过程略。\n对于外参RT，则直接代表了相机坐标系与世界坐标系之间关系。旋转矩阵R表示世界坐标系在相机坐标系下的姿态，平移矩阵T代表世界坐标系原点在相机坐标系下的位置。根据旋转矩阵的性质，可知相机在世界坐标系中的位置为\n相机坐标系归一化\r在将世界坐标点转换到相机坐标系后，再除掉它最后一个维度的数值（Z值，表示该点距离相机成像平面的深度）。这一归一化操作，得到了相机坐标系下的点P在相机归一化平面中的投影：\n这个归一化坐标可以看成是相机前方z=1处平面（相机归一化平面）上的一个点。在相机的视角上，归一化后的点的位置与原本的P点位置没有区别。因此我们可以拿归一化坐标(X\u0026rsquo;,Y\u0026rsquo;,1)做与像素坐标系的转换：\n这个变换背后的物理意义是，在世界坐标系中的点投射在成像平面上时，点的深度信息在投影过程中丢失了，单目视觉中无法得到像素点的深度值，简单来说，就是信息维度的减少。\n这样，我们就成功将小孔相机成像的几何过程，通过一组线性模型来拟合出来了：只要知道相机的内外参（相机像素焦距、相机中心点像素位置、相机在场景中的位置和姿态），就可以根据一个点在世界中的位置，计算出它在相机的像素位置。\n镜头畸变\r理想的透镜是没有畸变的。但是，因为制造和安装精度等方面的原因，镜头总是存在这畸变。畸变是相机固有特性，同款相机的畸变也会有些许差异。因此，广义上的相机内参，除了包含上述的K矩阵外，还包含相机镜头的畸变系数。镜头畸变分为径向畸变（Radial Distortion）和切向畸变（Tangential Distortion）。径向畸变来源于相机透镜在制造过程中的误差,而切向畸变则来源于整个相机的组装误差。\n径向畸变 径向畸变来自透镜形状不规则以及建模的方式，导致镜头不同部分焦距不同。光线在透镜边缘的弯曲程度和在透镜中心的弯曲程度不同，导致了畸变的发生。在到达图像传感器之前，光线从其理想位置径向向内移动，造成枕型畸变，或径向向外移动，造成桶形畸变。\n相机光轴中心的畸变为0，沿着镜头半径方向向边缘移动，畸变越来越严重。畸变的数学模型可以用主点（principle point）周围的泰勒级数展开式的前几项进行描述，通常使用前两项，即k1和k2，对于畸变很大的镜头，如鱼眼镜头，可以增加使用第三项k3来进行描述，图像上某点根据其在径向方向上的分布位置，消除径向畸变的调节公式为：\n其中(x,y)表示归一化后的相机坐标系中的一点，k1、k2和k3即为透镜的径向畸变系数。等式左边是去畸变后的坐标。\n切向畸变 切向畸变来自于整个摄像机的组装过程。由于透镜制造上的缺陷使得透镜本身与图像平面不平行而产生的，如下图所示：\n切向畸变可以用两个参数p1和p2来描述：\n与径向畸变情况相同，这里(x,y)表示归一化后的相机坐标系中的一点，p1、p2为透镜的切向畸变系数。等式左边是去畸变后的坐标。\n径向畸变与切向畸变共同作用在位于归一化的相机坐标系上的点，就有：\n等式左边是去畸变后的x坐标，y坐标道理相同。因此，对于相机镜头的畸变模型，通常使用5个畸变系数来进行描述。\n根据这两种畸变模型，我们也应该注意到，对于一个相机，它的图像的某一点上的畸变系数，是不随点的位置变化而变化的。只利用相机图像的一部分区域得到的畸变系数，在图像的所有位置上都适用。\n非线性成像模型\r小孔成像模型是线性的，只要相机拍摄多张照片，找到真实世界中的多个点的位置与他们在图像中对应的像素点的位置，理论上就可以求出精度很高的相机参数。但也仅仅是理论上，因为真实的成像过程，但在小孔成像模型外引入的畸变模型是非线性的，在只知道世界坐标点和它们在图像中畸变后的位置，是无法通过解析法直接求取参数的。这就是为什么前文提到，我们无法准确求取相机参数，只能想办法“估算”一个数学模型，来“逼近”相机真实的成像过程。\n相机标定流程\r到目前为止，单目相机的数学模型已经建立起来了。\n对于一个已经组装好的相机镜头，它的内参和畸变系数是确定的，不变的。但它的外参，会随着相机与实际场景中参照物的相对位置的变化而变化。因此，为了满足MetaSense项目或其他项目，对我们自研的双目相机的单个镜头的内外参与畸变系数的使用要求，我们需要在两个不同的时间和地点完成相机的标定，得到相机单个镜头的内外参和畸变系数，以及双目镜头之间的其他参数（详见双目相机标定，有待完善）。\n在相机组装完成，具备了镜头视频流推送的功能后，对相机进行内参标定，获取每个镜头的内参、畸变系数，与双目镜头之间的其他参数。这些数据会被保存。 当相机被固定在特定的使用场景中之后，在确保相机位置不会轻易改变后，利用相机在出厂前标定的内参，进行外参标定，也就是获得每个相机在场景中的位置。 问题与解答\r相机分辨率改变时，参数如何变化？ 当多相机的外参整体出现偏倚时，如何补救？ 有哪些用途的相机需要进行标定？ 拍摄标定照片时，照片的拍摄方式如何确定？ 在跨场景外参标定时，如何保证参数的传递？ 参考资料\n• Z. Zhang, \u0026ldquo;A flexible new technique for camera calibration\u0026rsquo;\u0026rdquo;, IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol.22, No.11, pages 1330–1334, 2000\n• https://en.wikipedia.org/wiki/Camera_resectioning\n• https://docs.opencv.org/4.x/dc/dbb/tutorial_py_calibration.html\n• https://ww2.mathworks.cn/help/vision/ug/camera-calibration.html\n• https://www.analyticsvidhya.com/blog/2021/10/a-comprehensive-guide-for-camera-calibration-in-computer-vision/\n• https://zhuanlan.zhihu.com/p/583883569\n• https://zhuanlan.zhihu.com/p/52322904\n• https://www.cnblogs.com/yutian-blogs/p/13543481.html\n","date":"2023-08-05T23:34:28+08:00","permalink":"https://zeel210.github.io/p/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0/","title":"相机标定原理概述"},{"content":"引文\r双目相机标定，从广义上讲，其实它包含两个部分内容：\n• 两台相机各自误差的标定（单目标定）\n• 两台相机之间相互位置的标定（狭义，双目标定）\n本文的双目标定是狭义的，单指两台相机之间相互位置的标定。而在实际代码实践时，我们所说的双目相机标定是包括内外参标定、畸变矫正与相机矫正等一套完整的过程。\n双目相机标定目的\r获取两台相机之间的相对位置关系，从而进行后续的算法计算。 得到相对位置关系后，对双目相机进行校正。校正的目的是让左右相机的同名点（被摄点在左右图像的点对），在两个相机中的y轴坐标一致。 双目极线校正\r双目模型：\n其中：\n基线：两个光心的连线称为基线；\n极平面：物点（空间点P）与两个光心的连线构成的平面称为极平面；\n极线：极平面与成像平面的交线\n极点：极线的一端，基线与像平面的 交点\n像点：极线的一端，光心与物点连线与像平面的交点。\n如上图所示，一般情况下，由于双目镜头的组装很难达到理想状态，因此相机的光心不是相互平行的。两个相机获取的同一物点的相机坐标在y方向上不一致。当需要对一个相机画面中某物点与另一台相机画面进行匹配时，就需要x和y两个方向上遍历画面。如果我们能够让两个画面中物点的y坐标相同，即可大大提高遍历效率，提高运算性能，方便后续图像处理的很多操作。\n因此，我们在求取两相机间的位姿关系，以便后续的三维重建的同时，也需要利用两相机位姿数据，对双目相机进行极线校正（不同于单目标定中的畸变矫正）。矫正后的相机极点在无穷远处，两相机的光轴平行，像点在左右图像上的高度一致。标定+校正后图片如下：\n双目标定理论\r记：\n根据双目相机之间平移与旋转矩阵的定义，显然有：\n经过推导，得到R和T的计算公式（省略推导过程）：\n其中等式左侧的参数由单目内参标定计算得到。\n极线校正的计算方法较为复杂， 这里省略，不影响使用opencv进行实际校正操作。\n相机内参标定抓图规范：\r2022.8.5标定抓图方式：\r基本原则：\na. 相机：位置不变，镜头朝向可变。\nb. 标定板：左右位置不变，前后位置可变。能以竖直方向为轴做旋转，以改变其与相机成像平面的夹角。\nc. 标定板边缘不得处在镜头画面之外。\n抓图步骤：\n使标定板尽量铺满镜头画面。标定板正对镜头，相机抓取一张照片，左右侧对镜头，各抓取一张照片。 增大标定板与相机的距离，使标定板占据相机约四分之一的画面（四个标定板能铺满画面）。随后调整相机角度，使标定板分别铺满相机画面的九宫格，当标定板处在画面的每一个位置上时，调整标定板与相机的角度，再抓取一张照片： a. 在水平位置上，标定板处于画面中间位置时，标定板正对相机。\nb. 水平位置上，标定板处于画面左侧时，标定板逆时针转动一定角度，侧对相机。\nc. 水平位置上，标定板处于画面右侧时，标定板顺时针转动一定角度，侧对相机。\n继续增大标定板与相机的距离，使标定板占据相机约九分之一的画面（九个标定板能铺满画面）。随后分别在画面12宫格（4×3）的各个位置中以（2.）的方式抓取多张照片。 总计抓取3+9+12=24张标定照片。\n双目相机标定步骤\r基于已拍摄的标定照片和opencv，一个完整的双目相机标定步骤如下。\n利用单目相机标定方法，分别计算两个相机各自的内参和畸变系数，详见“单目相机标定”。 利用计算结果，使用initUndistortRectifyMap函数对双目相机同一时刻拍摄的标定照片进行处理，对左右照片进行畸变消除与双目校正，最后裁剪。 ","date":"2023-05-22T19:23:28+08:00","permalink":"https://zeel210.github.io/p/%E5%8F%8C%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/","title":"双目相机标定"},{"content":"Basic project\r最基本的CMake工程就是将一个源文件编译为一个可执行程序，需要包含以下三个内容\n1 2 3 cmake_minimum_required(VERSION 3.10) #指定最小可用的CMake版本 ，从而使得CMake版本兼容 project(MyTest) #指定项目名称 add_executable(MyTest main.cpp) #使用指定的源文件编译可执行程序 指定c++标准\rMethod\n注意CXX标准指定应在add_executable()调用之前，保证指定有效\n1 2 set(CMAKE_CXX_STANDARD xx) set(CMAKE_CXX_STANDARD_REQUIRED True) Example\n1 2 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) 添加库文件\r创建library ​\tMethod\n使用add_library()命令指定构建库所需的源文件\n当使用一个或多个子目录组织项目时，专门为库文件创建一个子目录，子目录中创建新的CMakeLists.txt文件用于库的编译，顶层CMakeLists.txt文件中使用add_subdirectory()将子目录添加至工程中，用于后续的构建\n使用target_include_directory()， target_link_library()将构建的库文件连接到可执行目标\n​\tExample\n基于下面的目录结构，在子目录src/将subject.cpp文件编译成动态链接库，并在顶级目录下进行链接\n├── CMakeLists.txt\n├── README\n├── src\n│ ├── CMakeLists.txt\n│ ├── common.h\n│ ├── subject.cpp\n│ └── subject.h\n└── test\n​ └── demo.cpp\nsrc/CMakeLists.txt:\n1 2 3 4 5 6 7 cmake_minimum_required(VERSION 3.15) project(SubjectTest) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED True) # 配置编译选项 add_compile_options(-Wall -Wextra -Werror) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -pthread -std=c++14\u0026#34;) add_library(SubjectTest SHARED subject.cpp) 注意，target_include_directory()， target_link_library()使用应在add_executable()之后。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cmake_minimum_required(VERSION 3.15) project(MyProject) set(CMAKE_CXX_STANDARD 14) # 配置编译选项 add_compile_options(-Wall -Wextra -Werror) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -pthread -std=c++14\u0026#34;) add_subdirectory(src) message(STATUS \u0026#34;include path: ${CMAKE_CURRENT_SOURCE_DIR}\u0026#34;) include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/src ) # 设置要编译的可执行文件 set(TEST_SOURCES test/demo.cpp ) # Build the executable add_executable(test ${TEST_SOURCES}) target_include_directories(test PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${PROJECT_SOURCE_DIR}/src\u0026#34;) target_link_libraries(test PUBLIC SubjectTest) 使用条件语句\roption()允许用户自定义指定CMake构建过程，并为用户提供一个变量可在CMake构建时按值实现自定义构建.\n使用接口库指定c++标准(INTERFACE Library)\rMethod\n在前文中构建basic project中提到CMake构建时需要指定cxx标准，除了上面的方法，还可以用接口库进行指定，接口库是一种特殊类型的库，他只包含头文件，并不包含实际源代码与链接库，用于定义接口与依赖关系，并在不同目标之间共享接口。\n接口库需要用关键字INTERFACE指明，需要创建、定义、链接等步骤.\nExample\n1 2 3 4 5 6 7 8 9 add_library(tutorial_compiler_flags INTERFACE) # 用于指定编译目标的编译特性，它允许用户在构建过程中声明目标所需的语言特性或编译器功能，以确保正确的编译环境 target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11) # 同样需要将该interface library连接到要构建的可执行程序中 target_link_libraries(Tutorial PUBLIC MathFunctions tutorial_compiler_flags) ------- 可实现替代下面的语句 --------- # # specify the C++ standard # set(CMAKE_CXX_STANDARD 11) # set(CMAKE_CXX_STANDARD_REQUIRED True) 生成表达式\r该表达式用于在构建过程中动态生成值，提供一种脚本中进行条件判断、迭代、选择的灵活用法.\n常见用法：有条件的添加编译器标志，例如用于语言级别或警告的标志\n$\u0026lt;TARGET_PROPERTY:target,prop\u0026gt;获取目标属性的值，检查其是否匹配，如果编译器的语言和标识符与提供的参数匹配；否则返回零（false)\n$\u0026lt;CONDITION:VALUE_IF_TRUE;VALUE_IF_FALSE\u0026gt;，其中CONDITION是一个条件，VALUE_IF_TRUE和VALUE_IF_FALSE是根据条件结果选择的值。\nMethod\n使用生成表达式添加不同的编译警告。\n使用了$\u0026lt;COMPILE_LANG_AND_ID: lang, id\u0026gt;生成器表达式来判断当前编译器是否属于GCC风格的C++编译器，根据表达式返回值给变量gcc_like_cxx赋值。 1 2 3 4 5 6 set(gcc_like_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC\u0026gt;\u0026#34;) set(msvc_cxx \u0026#34;$\u0026lt;COMPILE_LANG_AND_ID:CXX,MSVC\u0026gt;\u0026#34;) target_compile_options(tutorial_compiler_flags INTERFACE \u0026#34;$\u0026lt;${gcc_like_cxx}:-Wall;-Wextra;-Wshadow;-Wformat=2;-Wunused\u0026gt;\u0026#34; \u0026#34;$\u0026lt;${msvc_cxx}:-W3\u0026gt;\u0026#34; ) 安装\r将编译的内容安装至本地指定目录 安装可执行文件，将可执行文件安装至bin/ 目录 安装动态链接库、静态链接库，将库文件安装至 lib/ 目录 安装头文件 ，安装至include/ 目录 Method\n1 2 3 install(TARGETS \u0026lt;your_targets_name\u0026gt; DESTINATION \u0026lt;your_target_dir\u0026gt;） #具体编译时，如果写的是相对路径，需要指定prefix，否则将会安装的系统路径下，可通过sh脚本指定 #example: cmake --install . --prefix \u0026#34;./release\u0026#34; Example\n该示例是对上面创建库CMakeLists.txt文件的补充，可将生成的可执行程序、库文件、头文件安装至指定目录.\n顶级目录下的CMakeLists.txt：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 cmake_minimum_required(VERSION 3.15) project(MyProject) set(CMAKE_CXX_STANDARD 14) # 配置编译选项 add_compile_options(-Wall -Wextra -Werror) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -pthread -std=c++14\u0026#34;) add_subdirectory(src) message(STATUS \u0026#34;include path: ${CMAKE_CURRENT_SOURCE_DIR}\u0026#34;) include_directories( ${CMAKE_CURRENT_SOURCE_DIR}/src ) # install include file install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src DESTINATION include FILES_MATCHING PATTERN \u0026#34;*.h\u0026#34;) # # Add your test source files set(TEST_SOURCES test/demo.cpp ) # Build the executable add_executable(test ${TEST_SOURCES}) target_include_directories(test PUBLIC \u0026#34;${PROJECT_BINARY_DIR}\u0026#34; \u0026#34;${PROJECT_SOURCE_DIR}/src\u0026#34;) target_link_libraries(test PUBLIC SubjectTest) install(TARGETS test DESTINATION bin) 子目录：src/CMakeLists.txt：\n1 2 3 4 5 6 7 8 9 10 11 12 cmake_minimum_required(VERSION 3.15) project(SubjectTest) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED True) # 配置编译选项 add_compile_options(-Wall -Wextra -Werror) set(CMAKE_CXX_FLAGS \u0026#34;${CMAKE_CXX_FLAGS} -pthread -std=c++14\u0026#34;) add_library(SubjectTest SHARED subject.cpp) install(TARGETS SubjectTest LIBRARY DESTINATION lib) 使用命令cmake --install . --prefix \u0026quot;./release\u0026quot;编译后，再当前目录的release文件夹下存在如下文件结构，安装成功。\n├── release\n│ ├── bin\n│ │ └── test\n│ ├── include\n│ │ └── src\n│ │ ├── common.h\n│ │ └── subject.h\n│ └── lib\n│ └── libSubjectTest.so\ninclude()用法\rMethod\n￮ module是包含CMake模块的名称，该module是包含CMake脚本的文件，用于提供额外的功能，会根据预定的模块路径搜索指定的module文件并加载内容\n优点 提供额外功能，轻松扩展CMake的能力，从而更好地满足项目的要求 代码复用和模块化，保持代码的一致性与可维护性 提高配置和构建的可读性，将配置和构建过程分解为更小的模块，使得CMakeLists.txt文件更易于理解和维护 1 include(\u0026lt;module\u0026gt;) Example\n文件结构 在\u0026quot;${CMAKE_CURRENT_SOURCE_DIR}/cmake\u0026quot;文件夹下有如下几个模块 ├── cmake\n│ ├── 3rdpart.cmake\n│ ├── build_option.cmake\n│ ├── nt98566\n│ │ └── ast.cmake\n│ └── x86_64\n│ └── ast.cmake\n├── CMakeLists.txt\n顶层目录CMakeLists.txt 首先将module路径加载至CMake变量CMAKE_MODULE_PATH中 使用include导入各模块 1 2 3 4 5 #加载自定义模块 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/cmake\u0026#34;) include(build_option) include(3rdpart) include(${PLATFORM}/ast) ","date":"2023-04-02T11:32:28+08:00","permalink":"https://zeel210.github.io/p/%E5%B8%B8%E7%94%A8cmakelists.txt%E7%BC%96%E5%86%99%E6%8C%87%E5%BC%95/","title":"常用CMakeLists.txt编写指引"},{"content":"详细的内参矩阵、外参矩阵和畸变系数的求解方法和数学推导，见：\n相机标定之张正友标定法数学原理详解\n到此我们大致了解了相机标定的理论支撑。在实际应用中，我们基于opencv封装的标定方法，编写相机标定程序。我们对单目相机的标定步骤如下：\n打开相机，拍摄多张处在不同位置、不同角度的标定板照片。最少需要3张，以10~20张为宜。标定板需要是黑白相间的矩形构成的棋盘图,照片质量越高越好。\n运行标定程序，依次完成以下步骤。\n提取内角点：遍历某文件夹下的所有照片，使用findChessboardCorners函数提取每张照片中标定板的内角点。 提取亚像素信息：为了提高标定精度，需要在初步提取的角点信息上使用cornerSubPix函数进一步提取亚像素信息，降低相机标定偏差。 绘制内角点：在棋盘标定图上绘制找到的内角点，按顺序显示并保存。 相机标定：使用calibrateCamera函数进行标定，计算相机内参矩阵、外参矩阵和畸变矩阵。 评价标定结果：对标定结果进行评价的方法是通过得到的摄像机内外参数，对空间的三维点进行重新投影计算，得到空间三维点在图像上新的投影点的坐标，计算投影坐标和亚像素角点坐标之间的偏差，偏差越小，标定结果越好。 畸变矫正：利用求得的相机的参数数据，使用initUndistortRectifyMap和remap两个函数对图像进行畸变的矫正。 ","date":"2022-08-23T18:56:28+08:00","permalink":"https://zeel210.github.io/p/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E5%86%85%E5%8F%82%E6%A0%87%E5%AE%9A/","title":"单目相机内参标定"}]